package com.learnings.designPatterns.v8.chaining;

import com.learnings.designPatterns.v8.chaining.function.Consumer;
import com.learnings.designPatterns.v8.chaining.function.Function;
import com.learnings.designPatterns.v8.chaining.function.Predicate;
import com.learnings.designPatterns.v8.model.Meteo;

public class Driver {

    public static void main(String[] args) {
        Consumer<String> c1 = s -> System.out.println("c1 => " + s);
        Consumer<String> c2 = s -> System.out.println("c2 => " + s);

        // Chained the consumer, meaning the consumer c3 takes in a string s and is accepted by c1 and c2
        Consumer<String> c3 = s -> {
            c1.accept(s);
            c2.accept(s);
        };

        c3.accept("Wassup");

        // But for chaining -> 
        /**
         * We should be able to chain it programatically and not with hard-coding.
         * 
         * So, something like -> 
         * 
         * c3 = c1.andThen(c2);
         *    This means that andThen method takes a consumer i/p and it applies the accept on c2 as well.
         * 
         */

        
        c3 = c1.andThen(c2);
        c3.accept("Yo");

        /// Same goes for predicates
        Predicate<String> p1 = s -> s != null;
        Predicate<String> p2 = s -> !s.isEmpty(); 

        Predicate<String> p3 = p1.and(p2);
        Predicate<String> p4 = p3.negate();
        p3.test("");

        p4.test("Lets this if this predicate works");

        // Functions
        // Takes a metoe object and return the temperature
        Function<Meteo, Integer> readCelius = m -> m.getTemperature();
        // Takes the integer celcius and coverts to farh
        Function<Integer, Double> celiusToFahrenheit =  c -> c * 9d/5d + 32d;
        // This was chaining
        Function<Meteo, Double> readAndThenConvert = readCelius.andThen(celiusToFahrenheit);

        Meteo m = new Meteo(20);
        System.out.println("Meteo in far " + readAndThenConvert.apply(m));

        // Composition of functions
        // Composition is almost the same but with some changes to the way the function is composed.
        // So, the function can also be generated by composition
        // Composition can only happen on Functions bcz it can return different return types other than the input types
        readAndThenConvert = celiusToFahrenheit.compose(readCelius);
        System.out.println("Meteo in far " + readAndThenConvert.apply(m));

        // Static methods and also be used as factory methods on the interface
    }

}